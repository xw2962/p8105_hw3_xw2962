---
title: "p8105_hw3_xw2962"
author: "Xiaoyu Wu"
date: "2023-10-06"
output: github_document
---

## Load `Instacart` Dataset

```{r,message=FALSE}
library(tidyverse)
library(dplyr)
library(p8105.datasets)
data("instacart")
```

## Problem One 

#### Short descriptions of the dataset:

Dataset "instacart" has `r ncol(instacart)` variables: `r colnames(instacart)`. In this dataset, there are `r nrow(instacart)` rows. And there are `r ncol(instacart)` columns. Here we consider variables "order_dow", "order_hour_of_day","product id", "product_name", "aisle_id" and "aisle"to be important for analysis.

**Q1: How many aisles are there, and which aisles are the most items ordered from?**
```{r}
n_distinct(instacart$aisle_id)
# find how mant disctint aisles are there 
instacart |>
  group_by(aisle_id) |>
  summarize(n_obs = n()) |>
  arrange(desc(n_obs))
# find which aisle ids are the most items ordered from
instacart |>
  group_by(aisle) |>
  summarize(n_obs = n()) |>
  arrange(desc(n_obs))
# find which aisle names are the most items ordered from
```

#### Description

There are `r n_distinct(instacart$aisle_id)` aisles. Aisles with id: 83, 24 and 123 are the most items ordered from. And their corresponding aisle names are: fresh vegetables, fresh fruits and packaged vegetables fruits.     

**Q2: Make a plot that shows the number of items ordered in each aisle, limiting this to aisles with more than 10000 items ordered. Arrange aisles sensibly, and organize your plot so others can read it.**
```{r}
instacart |> 
  group_by(aisle) |>
  summarize(n_obs = n()) |>
  filter(n_obs>10000) |>
  mutate(aisle = forcats::fct_reorder(aisle, n_obs)) |>
  ggplot(aes(x=aisle,y=n_obs)) + 
  geom_bar(stat = "identity") +
  labs(
    title = "Number of Items Ordered in each Aisle",
    x = "Aisle Name",
    y = "Number of Items",
    caption = "Data from the p8105.datasets"
  ) +
   coord_flip()
```

#### Comment 

For showing the number of items ordered in each aisle, we first grouped the observations by aisle and summarized the number of observation in each group. We then filtered out the aisles with more than 10000 items ordered. Next, we plot a horizontal bar chart with aisle names on the x-axis and number of observations on the y-axis by ordering aisle names with most number of observations to aisle names with least number of observations.  

**Q3: Make a table showing the three most popular items in each of the aisles “baking ingredients”, “dog food care”, and “packaged vegetables fruits”. Include the number of times each item is ordered in your table.**
```{r, message=FALSE}
rank_df_one=instacart |>
      filter(aisle=="baking ingredients"|aisle=="dog food care"|aisle=="packaged vegetables fruits") |>
      group_by(aisle,product_name) |>
      summarize(
        n_obs = n()) |>
      mutate(item_ranking = min_rank(desc(n_obs))) |>
      filter(min_rank(desc(n_obs)) < 4) |>
      arrange(aisle,item_ranking) |>
      knitr::kable(digits = 1)
rank_df_one
```

#### Comment 

For making a table showing the three most popular items in each of the aisles “baking ingredients”, “dog food care”, and “packaged vegetables fruits”, we first filtered out the rows with aisle names that are “baking ingredients”, “dog food care”, and “packaged vegetables fruits”. We then grouped the data by aisle and product name, summarizing the observations in each group and ranking the number of observations in descending order. We kept the top three products with top three highest number of observations. Finally, we arranged the table according to aisle and item ranking. 
In the table, we can see that: for aisle baking ingredients, the top three most popular items are Light Brown Sugar, 
Pure Baking Soda and Cane Sugar; for dog food care, the top three most popular items are Snack Sticks Chicken & Rice Recipe Dog Treats,Organix Chicken & Brown Rice Recipe and Small Dog Biscuits; for packaged vegetables fruits, the top three most popular items are Organic Baby Spinach,Organic Raspberries and Organic Blueberries. 

**Q4: Make a table showing the mean hour of the day at which Pink Lady Apples and Coffee Ice Cream are ordered on each day of the week; format this table for human readers (i.e. produce a 2 x 7 table).** 
```{r, message=FALSE}
day_ave_df=instacart |>
      filter(product_name=="Pink Lady Apples"|product_name=="Coffee Ice Cream") |>
      group_by(product_name,order_dow) |>
      summarize(
         mean_hour = mean(order_hour_of_day, na.rm = TRUE)) |>
      select(product_name,mean_hour,order_dow)  |>
      arrange(order_dow) |>
      pivot_wider(
        names_from = product_name,
        values_from = mean_hour) |>
      mutate(
    order_dow = recode(order_dow, "0" = "Sunday", "1" = "Monday", "2" = "Tuesday","3" = "Wednesday","4" = "Thursday","5" = "Friday","6" = "Saturday")) |>
      knitr::kable(digits = 1)
day_ave_df
```

#### Comment

For making a table showing the mean hour of the day at which Pink Lady Apples and Coffee Ice Cream are ordered on each day of the week, we first filtered out the rows with product names "Pink Lady Apples" and "Coffee Ice Cream". Then we grouped our observations by product_name and order_dow. Next, we summarized the mean of order_hour_of_day in each group. We also selected product_name,mean_hour,order_dow to be shown in the table and arranged them by order_dow. For the last step, we used pivot wider, names mutation and knitr to make our table more readable. The resulting table have three columns:order_dow, Coffee Ice Cream and Pink Lady Apples.      

## Problem Two

## Load ` BRFSS` Dataset

```{r}
library(p8105.datasets)
data("brfss_smart2010")
```

```{r}
brfss_smart_df=
   brfss_smart2010 |> 
  janitor::clean_names() |> 
# format the data to use appropriate variable names
  filter(topic=="Overall Health") |>
# focus on the “Overall Health” topic
  filter(response=="Excellent"|response=="Fair"|response=="Good"|response=="Poor"|response=="Very good") |>
# include only responses from “Excellent” to “Poor”
  mutate(response=as.factor(response)) |> 
  mutate(response=forcats::fct_relevel(response,c("Poor","Fair","Good","Very good","Excellent")))
# organize responses as a factor taking levels ordered from “Poor” to “Excellent”
brfss_smart_df
```

